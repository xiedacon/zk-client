/**
 * xiedacon created at 2019-06-03 17:43:42
 *
 * Copyright (c) 2019 xiedacon, all rights reserved.
 */

import jute from './jute';

/**
 * org.apache.zookeeper.CreateMode
 */
export const CreateMode = {
  /**
   * The znode will not be automatically deleted upon client's disconnect.
   */
  PERSISTENT: 0,
  /**
   * The znode will not be automatically deleted upon client's disconnect,
   * and its name will be appended with a monotonically increasing number.
   */
  PERSISTENT_SEQUENTIAL: 2,
  /**
   * The znode will be deleted upon the client's disconnect.
   */
  EPHEMERAL: 1,
  /**
   * The znode will be deleted upon the client's disconnect, and its name
   * will be appended with a monotonically increasing number.
   */
  EPHEMERAL_SEQUENTIAL: 3,
  /**
   * The znode will be a container node. Container
   * nodes are special purpose nodes useful for recipes such as leader, lock,
   * etc. When the last child of a container is deleted, the container becomes
   * a candidate to be deleted by the server at some point in the future.
   * Given this property, you should be prepared to get ExceptionCode.NO_NODE
   * when creating children inside of this container node.
   */
  CONTAINER: 4,
  /**
   * The znode will not be automatically deleted upon client's disconnect.
   * However if the znode has not been modified within the given TTL, it
   * will be deleted once it has no children.
   */
  PERSISTENT_WITH_TTL: 5,
  /**
   * The znode will not be automatically deleted upon client's disconnect,
   * and its name will be appended with a monotonically increasing number.
   * However if the znode has not been modified within the given TTL, it
   * will be deleted once it has no children.
   */
  PERSISTENT_SEQUENTIAL_WITH_TTL: 6,
};

/**
 * org.apache.zookeeper.ZooDefs.OpCode
 */
export const OpCode = {
  notification: 0,
  create: 1,
  delete: 2,
  exists: 3,
  getData: 4,
  setData: 5,
  getACL: 6,
  setACL: 7,
  getChildren: 8,
  sync: 9,
  ping: 11,
  getChildren2: 12,
  check: 13,
  multi: 14,
  create2: 15,
  reconfig: 16,
  checkWatches: 17,
  removeWatches: 18,
  createContainer: 19,
  deleteContainer: 20,
  createTTL: 21,
  multiRead: 22,
  auth: 100,
  setWatces: 101,
  sasl: 102,
  getEphemerals: 103,
  getAllChildrenNumber: 104,
  setWatches2: 105,
  addWatch: 106,
  createSession: -10,
  closeSession: -11,
  error: -1,
};

/**
 * org.apache.zookeeper.ZooDefs.Perms
 */
export const Perms = {
  READ: 1,
  WRITE: 2,
  CREATE: 4,
  DELETE: 8,
  ADMIN: 16,
  ALL: 31,
};

/**
 * org.apache.zookeeper.ClientCnxn
 */
export const Xid = {
  /**
   * -1 means notification(WATCHER_EVENT)
   */
  notification: -1,
  /**
   * -2 is the xid for pings
   */
  ping: -2,
  /**
   * -4 is the xid for AuthPacket
   */
  authentication: -4,
  /**
   * -8 is the xid for setWatch
   */
  setWatches: -8,
};

/**
 * org.apache.zookeeper.Watcher.WatcherType
 */
export const WatcherType = {
  Children: 1,
  Data: 2,
  Any: 3,
};

/**
 * org.apache.zookeeper.Watcher.Event.EventType
 */
export const EventType = {
  None: -1,
  NodeCreated: 1,
  NodeDeleted: 2,
  NodeDataChanged: 3,
  NodeChildrenChanged: 4,
  DataWatchRemoved: 5,
  ChildWatchRemoved: 6,
  PersistentWatchRemoved: 7,
};

/**
 * org.apache.zookeeper.Watcher.Event.KeeperState
 */
export const EventState = {
  /**
   * Unused, this state is never generated by the server.
   */
  Unknown: -1,
  /**
   * The client is in the disconnected state - it is not connected
   * to any server in the ensemble.
   */
  Disconnected: 0,
  /**
   * Unused, this state is never generated by the server.
   */
  NoSyncConnected: 1,
  /**
   * The client is in the connected state - it is connected
   * to a server in the ensemble (one of the servers specified
   * in the host connection parameter during ZooKeeper client
   * creation).
   */
  SyncConnected: 3,
  /**
   * Auth failed state.
   */
  AuthFailed: 4,
  /**
   * The client is connected to a read-only server, that is the
   * server which is not currently connected to the majority.
   * The only operations allowed after receiving this state is
   * read operations.
   * This state is generated for read-only clients only since
   * read/write clients aren't allowed to connect to r/o servers.
   */
  ConnectedReadOnly: 5,
  /**
   * SaslAuthenticated: used to notify clients that they are SASL-authenticated,
   * so that they can perform Zookeeper actions with their SASL-authorized permissions.
   */
  SaslAuthenticated: 6,
  /**
   * The serving cluster has expired this session. The ZooKeeper
   * client connection (the session) is no longer valid. You must
   * create a new client connection (instantiate a new ZooKeeper
   * instance) if you with to access the ensemble.
   */
  Expired: -122,
  /**
   * The client has been closed. This state is never generated by
   * the server, but is generated locally when a client calls
   */
  Closed: 7,
};

/**
 * org.apache.zookeeper.KeeperException.Code
 */
export const ExceptionCode = {
  /**
   * Everything is OK.
   */
  OK: 0,
  /**
   * System and server-side errors.
   * This is never thrown by the server, it shouldn't be used other than
   * to indicate a range. Specifically error codes greater than this
   * value, but lesser than ExceptionCode.API_ERROR, are system errors.
   */
  SYSTEM_ERROR: -1,
  /**
   * A runtime inconsistency was found.
   */
  RUNTIME_INCONSISTENCY: -2,
  /**
   * A data inconsistency was found.
   */
  DATA_INCONSISTENCY: -3,
  /**
   * Connection to the server has been lost.
   */
  CONNECTION_LOSS: -4,
  /**
   * Error while marshalling or unmarshalling data.
   */
  MARSHALLING_ERROR: -5,
  /**
   * Operation is unimplemented.
   */
  UNIMPLEMENTED: -6,
  /**
   * Operation timeout.
   */
  OPERATION_TIMEOUT: -7,
  /**
   * Invalid arguments.
   */
  BAD_ARGUMENTS: -8,
  /**
   * No quorum of new config is connected and up-to-date with the leader of last commmitted config
   * try invoking reconfiguration after new servers are connected and synced
   */
  UNKNOWN_SESSION: -12,
  /**
   * Another reconfiguration is in progress -- concurrent reconfigs not supported (yet).
   */
  NEW_CONFIG_NO_QUORUM: -13,
  /**
   * Unknown session (internal server use only).
   */
  RECONFIG_IN_PROGRESS: -14,
  /**
   * API errors.
   * This is never thrown by the server, it shouldn't be used other than
   * to indicate a range. Specifically error codes greater than this
   * value are API errors (while values less than this indicate a ExceptionCode.SYSTEM_ERROR.
   */
  API_ERROR: -100,
  /**
   * Node does not exist.
   */
  NO_NODE: -101,
  /**
   * Not authenticated.
   */
  NO_AUTH: -102,
  /**
   * Version conflict
   * In case of reconfiguration: reconfig requested from config version X but last seen config has a different version Y.
   */
  BAD_VERSION: -103,
  /**
   * Ephemeral nodes may not have children.
   */
  NO_CHILDREN_FOR_EPHEMERALS: -108,
  /**
   * The node already exists.
   */
  NODE_EXISTS: -110,
  /**
   * The node has children.
   */
  NOT_EMPTY: -111,
  /**
   * The session has been expired by the server.
   */
  SESSION_EXPIRED: -112,
  /**
   * Invalid callback specified.
   */
  INVALID_CALLBACK: -113,
  /**
   * Invalid ACL specified.
   */
  INVALID_ACL: -114,
  /**
   * Client authentication failed.
   */
  AUTH_FAILED: -115,
  /**
   * Session moved to another server, so operation is ignored.
   */
  SESSION_MOVED: -118,
  /**
   * State-changing request is passed to read-only server.
   */
  NOT_READONLY: -119,
  /**
   * Attempt to create ephemeral node on a local session.
   */
  EPHEMERAL_ON_LOCAL_SESSION: -120,
  /**
   * Attempts to remove a non-existing watcher.
   */
  NOWATCHER: -121,
  /**
   * Request not completed within max allowed time.
   */
  REQUEST_TIMEOUT: -122,
  /**
   * Attempts to perform a reconfiguration operation when reconfiguration feature is disabled.
   */
  RECONFIG_DISABLED: -123,
  /**
   * The session has been closed by server because server requires client to do SASL authentication,
   *  but client is not configured with SASL authentication or configuted with SASL but failed
   *  (i.e. wrong credential used.).
   */
  SESSION_CLOSED_REQUIRE_SASL_AUTH: -124,
};

export const ConnectionEvent = {
  // state events
  connecting: 'connecting',
  reconnecting: 'reconnecting',
  connect: 'connect',
  disconnect: 'disconnect',
  closing: 'closing',
  closed: 'closed',
  error: 'error',
};

const ANYONE_ID_UNSAFE = new jute.data.Id({ id: 'anyone', scheme: 'world' });
const AUTH_IDS = new jute.data.Id({ id: '', scheme: 'auth' });

/**
 * org.apache.zookeeper.ZooDefs.Ids
 */
export const Ids = {
  /**
   * This Id represents anyone.
   */
  ANYONE_ID_UNSAFE,
  /**
   * This Id is only usable to set ACLs. It will get substituted with the
   * Id's the client authenticated with.
   */
  AUTH_IDS,
  /**
   * This is a completely open ACL .
   */
  OPEN_ACL_UNSAFE: [ new jute.data.ACL({ id: ANYONE_ID_UNSAFE, perms: exports.Perms.ALL }) ],
  /**
   * This ACL gives the creators authentication id's all permissions.
   */
  CREATOR_ALL_ACL: [ new jute.data.ACL({ id: AUTH_IDS, perms: exports.Perms.ALL }) ],
  /**
   * This ACL gives the world the ability to read.
   */
  READ_ACL_UNSAFE: [ new jute.data.ACL({ id: ANYONE_ID_UNSAFE, perms: exports.Perms.READ }) ],
};
